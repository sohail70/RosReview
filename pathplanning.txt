Path planning can also be classified into holonomic path planning and nonholonomic path planning, depending on if kinemetic constraints are considered or not. If the generated path also considers
constraints on velocity and acceleration, the term kinodynamic path planning is used.
Also, based on the decomposition method of the environment used, path planning algorithms can be classified into deterministic planners and probabilistic planners

A common way of satisfying the requirements of a robust autonomous navigation system is to use a two-level planning architecture.
In such systems, a global path planner is paired with a local path planner and both work in a complementary manner.

The global path planner is concerned with long range planning and uses the available map information, which can be slow, but is key to finding the most efficient path to a distant goal. It is not concerned with
the robot's dynamics or how to avoid unexpected obstacles, which are left to the local path planner.


In this way, each planner deals with only one set of concerns: finding a traversable path to a distant goal, and following that path while reacting to unforeseen situations like the appearance of obstacles.
Therefore, global path planning and local path planning can be considered complementary solutions and are commonly built into path planning systems in real world applications.

In the global planning stage we try to find a collision free kinematically feasible path from start to goal while skipping the differential or dynamic constraints (so this is where obstacle avoidance should be happening)
In the local planning stage, we use path smoothing to meet the differential/dynamic constraints



-------------------------------------------
Dijkstra:

Important assumptions:
	The robot has a map
	The robot knows its location in it
	The environment does not change
	The robot can move up, down, left, or right, as long as the space is free
	
	
	
	
A key component of Dijkstra's algorithm is that it always keeps track of the shortest distance from the start node to each individual cell. We will refer to this value as the the g_cost of a node and
display it on each grid cell's lower right corner. Before the search process starts, the starting point (node Q) gets a g_cost of 0 (as its distance to itself is 0). Later, as the algorithm progresses, these values
will be updated to the actual shortest distance from the start node (more on that will follow soon).
Aditionally, we put node Q into a so-called open list. Nodes that are inside the open list are the color orange.

Iteration steps:
1) Pick a current node -->The iterative search process starts by picking the node inside open list with the lowest g_cost. We call this node current node. At this moment, open list only contains node Q. We will use a bold black
outline to identify the current node in the diagrams.

2) Neighbours of the current node-->We continue by examining adjacent nodes that are direct neighbours of the current node. In the example, we will only consider traversable grid cells above, below, to the right, and to the left of the current
node to be neigbours

3) Update travel distance values, store parent node--->Once we have identified all neighbour nodes in free space, we update their g_cost. Then, we set the parent node of each neighbour. The parent is the node from which the update of the g_cost came from
(which is always the current current node). On all diagrams, we will show each grid cell's parent node at the bottom of a grid cell, to the right of its g_cost. To conclude, we put each neighbour inside open list

Let's begin with neighbour L, as there is no reason to prefer one neighbour node over another:
list.We add the g_cost of the current node (in this case, 0) with the step-cost. The step-cost is the cost incurred when moving to a neighbor cell. In this example, we assume that each grid cells side length
is 1, therefore, all step-costs will be equal to 1. We set 1 as the g_cost of L.
We set its parent node, which is Q.
Now we can put this neighbour inside open list.
Brilliant! We continue with adjacent cell V:
We add 0 (the g_cost of Q, our current node) with 1 to obtain 1. Therefore, we set the g_cost of V to 1.
We set as parent node Q.
Finally, we add V to open list.
OK. Apply the same steps again for P.
Awesome! We are done considering all neighbours of Q, therefore, we can mark node Q as visited. Visited nodes will be kept in a separate list called closed list and will be shown in yellow.
After the above steps, Dijkstra's algorithm has completed one full iteration cycle.


New cycle, repeat 1) pick a new current node, 2) check neighbours, 3) update g_cost and parent node

Now we are at the beginning of a new iteration cycle, so we need to select a new current node to explore. We pick a node from inside open list. It has to be one of the nodes with the smallest g_cost value.
That could be node L, V, or P since all have a g_cost value of 1. We can pick any of them, so let's pick L and mark it with a bold black outline to identify it as the current node.


Now we repeat the process by updating the neighbours of L. We ignore nodes inside closed list (in this case, we ignore node Q) and occupied cells (G and M), therefore, we can only process neighbour node
K.


This is how we update g_cost and parent node of node K:
Add 1 (the g_cost of L, our current node) with 1 (the step-cost when moving from L to K) to obtain 2.
Set the g_cost of K to 2.
Set L as parent node of K.
We add K to open_list.



To wrap up this iteration cycle and prepare for the next one, add L to closed list. In the next iteration cycle, L shows up yellow to represent that it has been "visited".


.....haminjoori mirim jello ta iter e 3 
Notice that both neigbours, K and U, already have a g_cost value. In this case, we have to compare if the new g_cost is lower or not. As the new g_cost is also 2, it is not neccesary to updates K and U's
previous g_cost. Likewise, the parent node is not updated and remains as it was.



iter7
Pick a new current node: node U is the only candidate node eligible.
Since U doesn't have any non-visited neighbours, there are no further steps other than adding it to closed list.



iter 13
Set N as the current node.
Voilà! We have found node N and our goal!

Now you think you are done? Still not yet.
Dijkstra's algorithm is divided into two phases:
1. Explore the map to collect data
2. Utilize the collected data to build the shortest path


At the moment, we have finished phase 1.
By examining neighbors and deciding which nodes are parent to which other nodes, we build a representation of the connectivity of the free space. We also confirmed that a path to the goal location exists.
However, we have not yet built the sequence of nodes that a robot would need to visit to move from start to goal, so let's do that now.


Once we have reached the target node, we can extract the shortest route by following every single node's parent node until we reach the start node.
We first take the target node N and add it to a new list. Then we look up the parent for that node. We add node's N parent to the list, which is S. In the same way, we pick the parent's parent node and store it,
too. In this case, the parent of S is X, and we add X to the list. We keep iterating this process until we get the start node Q, which has no parent node.
Can you see why it is important during Phase 1 to keep track of each node's parent node?
Once the backtracking is complete, the newly created list will contain the shortest path as a sequence of grid cells to visit, but in the wrong order:

To have the path from start to end, so all we need to do is reverse it



find neighbours. Another quite common way of referring to the same concept is expansion, propagation, or generation of successors.
Lists are also important. There are two lists that we need as bookkeeping tools:
Open list (also known as unvisited nodes or frontier)
Closed list (or visited nodes)

To keep track of the shortest path, we use two variables: g_cost and parent node.

The g_cost is the cost of moving from the start to a particular node. It is computed by adding the g cost of a parent to the cost of moving from the parent to the node, the step-cost. In the example, we used
a fixed step‐cost of 1 because we assumed that each grid cell's side length is 1. A lower g_cost means a better path. Dijkstra uses the lowest g_cost as the decisive criteria to pick a new current node out of
open list.




















Here's a short description of the process:
1. Mark your initial node with a g_cost of 0, and add your initial node to open_list
Phase I:
Repeat the following while open_list is not empty:
1.
2.
3.
4.
Extract the node with the smallest g_cost from open_list and call it current_node
Mark it as visited by adding it into closed_list
Check if current_node is the target node, and if so, go to phase II; otherwise, continue with step 5
Find the neighbours of the current_node
For each node in the list of neighbours of current_node:
1. If a neighbour is inside closed_list, skip it and pick the next neighbour
1. If a neighbour is inside open_list:
If the new g_cost value is smaller than the current g_cost value:
Update its g_cost
Update its parent node
1. If a neighbour is not inside open_list:
Set its g_cost
Set its parent node
Add it to open_list
When we are done considering all neighbours of current_node, go to step 2.
Phase II:
Build the path from start to end.
1. Trace back from the target node to the start node, using each node's parent node.
